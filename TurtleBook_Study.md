# TurtleBook_Study
  
  
### 作者：冰红茶  
### 参考书籍：《编写可维护的JavaScript》   

------    



   最开始的时候看完了《javascript权威指南》的第一部分，然后看完第二部分客户端JS的前两章，发现这一部分的JS更加适合当一部“字典”来使用，而非学习教程。所以后面大方向开始转变，面向实际项目和复习原来的知识和提升个人职业修养为主。乌龟书是一本好书，讲了很多JS编程方面的风格和规范^_ ^
  
## 目录

## [一、编程风格与规范](#1)
### [1.1 基本格式化](#1.1)
### [1.2 注释](#1.2) 
### [1.3 语句与表达式](#1.3) 
### [1.4 变量，函数和运算符](#1.4)
## [二、编程风格与规范](#2)
### [2.1 UI层的松耦合](#2.1)
### [2.2 避免使用全局变量](#2.2) 
### [2.3 事件处理](#2.3) 
### [2.4 检测方法](#2.4)
### [2.5 错误处理](#2.5)

------ 		


<h2 id='1'> 一、编程风格与规范 </h2>
<h3 id='1.1'>1.1 基本格式化</h3>  

#### 1) 缩进层级 
> - 一般四个空格或者一个Tab作为一个缩进层级
#### 2) 语句结尾
> - 一般以左大括号“{”或者分号“；”或者右大括号“}”作为结尾
#### 3) 行的长度
> - JS是80个字符
#### 4) 换行 
> - 如果一行字符串写不下，最好是使用字符串拼接，在一行最后添加一个“+”，而不是简单写一个转义字符“\”，虽然转义字符也可以，但这是非法的，并不推荐。
#### 5) 数字 
> - 数字八进制已经被弃用，而且要写就要写完整，不要忽略了小数点之前或者之后的数
#### 6) 空行 
> - 在方法之间；
> - 在方法中的局部变量和第一条语句之间；
> - 在多行或者单行注释之前；
> - 在逻辑片段之间；
#### 7) 命名 
> - 变量和方法的命名遵循小驼峰命名法；
> - 构造函数采用大驼峰命名法；
> - 变量名的前缀采用名词，方法名的前缀采用动词；		
#### 8) undefined
> - 当我们初始化变量的时候，最好给一个确定的值或者null。五个原始类型中number，string，boolean，undefined使用typeof都能返回自身，唯独null比较奇怪，返回的是object。
#### 9) 对象直接量
> - 最好采用类似CSS的写法，分号改成逗号；
> - 不好的做法是通过new的方法建立对象后，又通过点号添加属性；
#### 10) 数组直接量
> - 最好采用方括号的写法；
> - 不好的做法是通过new的方法建立数组；

<h3 id='1.2'>1.2 注释</h3>  

#### 1) 单行注释
> - 注释放在代码的上一行，并于代码保持相同的缩进；
> - 注释的上一行应该空一行；
> - 注释也可以放在同一行，但是需要加一个Tab。
#### 2) 多行注释
> - 注释的上一行应该空一行；
> - 第一行是/\*,第二行以\*开始，并与上一行的星号\*对齐，然后空一格再跟接文本，最后一行是\*/。		
		
		/* 我是多行注释；
		 * 我还是是多行注释；
		 * 我仍然是注释；
		 */		
		 
#### 3) 文档注释
> - 第一行是/\*\*,第二行以\*开始，并与上一行的星号\*\*对齐，然后空一格再跟接文本，最后一行是\*\*/。
> - 方法和属性的说明在前面加上@符号；
> - 类似JavaDoc的风格；		
		
		/** 我是注释；
		 ** 我是注释；
		 @method{content;}；
		 **/			
		 

<h3 id='1.3'>1.3 语句与表达式</h3>  

#### 1) 块语句的括号
> - 按照Java风格的来就没错了，无论是单行还是多行，一律加括号，左括号紧接着语句，右括号独自一行；	
> - 在左括号之前和右括号之后各添加一个空格		

		if (x!==x) {		
			console.log("x是NaN");		
		}else{		
			console.log("x不是NaN");
		}		
		
#### 2) 避免使用
> - 不要使用with（主要用来省略前缀用的），因为在严格模式无法使用；
> - 避免使用continue，一切的continue都可以用if语句代替；		
#### 3) for in循环
> - 遍历对象的所有的属性，无论是自定义属性还是从父类继承过来的属性。但是由于继承过来的属性很容易使得程序终止，所以一般加以使用hasOwnPorperty()进行过滤，如：		
		
		var prop;		
		
		for (prop in object) {		
			if (object.hasOwnPorperty(prop)) {		
				console.log("object prop'name is " + prop);		
				console.log("object prop'value is " + object[prop]);
			}
		}		
		
> - 如果需要查找原型链，需要加上注释；
> - 尽量避免在数组中使用for in，因为数组有它自己的索引;	

<h3 id='1.4'>1.4 变量，函数和运算符</h3>  

#### 1) 变量声明
> - 声明提前 在函数体中，只要出现var的变量声明，无论前后，都会被提前在该函数内所有逻辑语句之前执行；
> - 假如没有var却有变量的定义，无论前后，该变量都会变成全局变量（实际上是称为全局上下文的一个属性）；
> - 所有的声明都应该人工提前和合并；
#### 2) 函数声明
> - 跟变量声明提前一样，函数的声明也会被提前，因为JS解释器在执行语句的时候会首先通过变量的声明来确定其作用域
#### 3) 函数调用间隔
> - 左圆括号和函数名之间没有空格，左大括号前面应该留有空格；
#### 4) 立即执行函数
> - 立即执行函数外面需要添加一对圆括号，以显示其立即执行，避免误解，如：		
		
		var num=(function() {	
			var num=10;
			return num+1;
		})();		
		
#### 5) 严格模式
> - “use strict”;
> - 最好进行局部使用，不要全局使用
#### 6) 相等比较
> - 在进行“==”或者“!=”比较的时候，会发生强制类型转换；
> - 字符串和布尔值会被强制转换成数字；
> - 对象如果预先定义了valueOf()方法，则使用valueOf()方法得到原始值，否则使用toString()的方法，日期类的对象由系统预先定义了valueOf()的方法；
> - 在进行“===”或者“!=”比较的时候，不会发生强制类型转换，只要类型不一样，结果就是false；
#### 7) eval()
> - 其实不仅是eval(),Function的构造函数new Function("字符串代码")，setTimeout()和setInterval()也可以执行字符串代码；
> - 建议不要使用此类函数；
> - JS在严格模式下，eval()禁止在一个作用域内创建新的变量或者函数；
#### 8) 原始了类型的包装对象
> - 五种原始类型中有三种有包装对象：Number，String，Boolean；
> - 建议尽量避免使用他们；

------ 		


<h2 id='2'> 二、编程事件</h2>
<h3 id='2.1'>2.1 UI层的松耦合</h3>  		

#### 1) 目标
> - 确保对一个组建的修改不会经常地影响其他的部分；
#### 2) 将JS从CSS中抽离
> - 不好的做法：		
		
		.box {		
			width: expression(document.body.offsetWidth + "px");
		}		
		
#### 3) 将CSS从JS中抽离
> - 不好的做法：直接在JS中添加具体的样式；		
> - 好的做法：在CSS中定义需要更新的样式，然后在JS中通过给元素调用不同类名的方式更改样式；
#### 3) 将JS从HTNL中抽离
> - 尽量避免使用内联方法，包括设置和绑定事件，建议都在JS中绑定好
#### 4) 将HTML从JS中抽离
> - 从服务器加载标签模板
> - 简单客户端模板 插槽"%s"的替换
> - 复杂客户端模板Handlebars
	
<h3 id='2.2'>2.2 避免使用全局变量</h3>  		

#### 1) 单全局变量方式
> - 创建一个第一无二的全局对象（不会与内置的API产生冲突），并将你所有的功能代码都挂载到这个全局对象上。
#### 2) 命名空间
> - 其实就是单全局变量方式的加强版，创建一个全局对象后，再进行功能分组，创建多个子单全局变量；
#### 3) 模块
> - 第二种扩充单全局变量的方式，如：
		
		YUI.add("module-name", function(Y) {		
		
			//模块正文，或者叫待执行的函数/工厂方法，其中Y是一个实例；				
			
		}, "version", { requires: [ “dependency1”， “dependency2” ] })；		
		
		
<h3 id='2.3'>2.3 事件处理</h3>  		

#### 1) 隔离应用逻辑
> - 将应用逻辑和事件处理的代码分离；
> - 不要分发时间对象event
>>>>>> ![图2-1 事件处理](https://github.com/hblvsjtu/JavaScript_Study/blob/master/picture/%E5%9B%BE2-1%20%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.png?raw=true)		
		
		
<h3 id='2.4'>2.4 检测方法</h3>  		

#### 1) 检测原始类型
> - 避免空比较null==某某某
> - 最佳实践，即使变量未定义也不要紧，因为会返回undefined，不会报错：		
		
		//检测数字
		if (typeOf name === "number") {		
			//内容处理
		}		
		
		//检测字符串
		if (typeOf name === "string") {		
			//内容处理
		}		
		
		//检测布尔量
		if (typeOf name === "boolean") {		
			//内容处理
		}		
		
		//检测undefined
		if (typeOf name === "undefined") {		
			//内容处理
		}		
		
		//检测null,直接使用===
		if (name === null) {		
			//因为如果使用typeOf的话，会返回object,这是一种无效的检测方法；
		}		
		
#### 2) 检测对象
> - 检测日期，正则表达式，错误类型和自定义对象的最佳实践，采用instanceof的方法		
		
		//检测日期
		if (name instanceof Date) {		
			//内容处理
		}		
		
		//检测正则表达式
		if (name instanceof RegExp) {		
			//内容处理
		}			
		
		//检测错误类型
		if (name instanceof Error) {		
			//内容处理
		}		
		
> - 但是无法使用instanceof检测函数和数组，因为不能进行跨帧（浏览器帧）使用，比如：		
		
		//true		
		frameAPersonInstance instanceOf frameAPerson		
		
		//false，尽管两个对象的定义完全一样
		frameAPersonInstance instanceOf frameBPerson		
		
> - 检测函数的最佳实践是使用typeOf，因为可以跨域进行检测，最佳实践：			
		
		//检测函数
		if (typeOf func === "function") {		
			//内容处理
		}	
		
> - 检测DOM的方法，由于采用typeOf会返回Object，有需要跨帧检测，采用in documment是最好的，最佳实践：
		
		//检测DOM的方法，
		if (name in documment) {		
			//内容处理
		}		
		
> - 检测数组的方法，由于采用typeOf会返回Object，有需要跨帧检测，采用“鸭式变形”的方式最好，这也是Array.isArray()的原理，最佳实践：
		
		//检测数组的方法
		if (Object.prototype.toString.call(value) === "[object Array]") {		
			//内容处理
		}		
		
#### 3) 检测属性
> - 有些属性的布尔值转换为false，如+0，-0，undefined，null，false，“”，所以不能通过简单的if读属性的值来检测属性是否存在，最好是使用运算符in，或者hasOwnProperty()，因为它不会读属性里面的值：
		
		//不好的方法
		if (prop) {		
			//内容处理
		}		
		
		//最佳的方法		
		if (prop in object) {		
			//内容处理
		}		
		
		//最佳的方法		
		if (object.hasOwnProperty(prop)) {		
			//内容处理
		}		
		
<h3 id='2.5'>2.5 错误处理</h3>  		

#### 1) 抛出错误
> - 只接受一个字符串参数，最佳实践：
		
		throw new error("这里有一个错误")		
		
> - 如果没有用try-catch语句来捕获的话，浏览器通常会直接显式该消息（message的消息）。当今大多数都有一个控制台，一旦发生错误都会在这里输出。
#### 2) 接住错误try-catch
> - catch(error) {//处理错误} 可以对错误进行处理
> - 基本错误类型
>> - EvalError 通过eval()函数发生的错误		
>> - RangeError 数字超出边界发生的错误	
>> - ReferenceError 期望对象不存在时发生的错误	
>> - SyntaxError eval()函数里面的代码发生的错误	
>> - URIError encodeURL()encodeURLComponent()decodeURL()decodeURLComponent()发生的错误	







